unit OlympusShare;
{ Summary: This unit allows the user to download images from a wireless enabled Olympus camera, leaving the originals on the SD card.

  OS:      Windows 10 and Ubuntu 18.04 both working well, Mac OS not tested
  DevTool: Lazarus 2.06 / FPC3.04
  Camera: Olympus OM-D E-M10 Mark I, Mark 3 tested working
  How it works: Main class TOiShareReader manages connection to the camera over a wireless signal.
                The TfpHTTPClient used in the conection is an component which is not installed in Lazarus by default and needs to be installed in the fpWeb library
                using Menu|Package!Install/Uninstall Packages.

  Why develop this program?  Olympus makes Android and iOS apps (Oi.Share) to allow WiFi download of images from their camera but do
  not have an app for PC, Mac or Linux desktops. While a web browser can be pointed at the camera URL, this is cumbersome, and automated
  downloading of image files is not possible using a web interfacem, or using the mobile and tablet Oishare app.
  Now that the previous EyeFi WiFi enabled SD cards are no longer maid, a WiFi connection for Windows, Linux and Mac is needed.

  'HOW TO USE THIS PROGRAM  + #13 + #10 + // TODO: need different EOL for Linux/macOS

     1.   Take some photos on your Olympus camera
     2.   Use the Olympus camera menu to select Connection to Smartphone.  This starts the camera WiFi server.
     3.   Connect your computer to this WiFi signal in the usual way for your operating system
     4.   Run this OlympusWIFI program
     5.   App Settings (Page 3): i)   Select your model of camera.  If your model is not there then use the Add button to add it.
                                 ii)  Ensure the "Olympus Camera Server URL" is set correctly.
                                      This is the same URL address minus the "/DCIM" you can type into a web browser to access your camera.
                                      Change the server URL if needed
                                      e.g. Model E-M10 Mark I URL = "http://oishare", Model E-M10 Mark III URL = "http://192.168.0.10"
                                 iii) Ensure the "SDCard Root Directory" is set correctly. This is usually "/DCIM". Need initial forward slash.
                                 iv)  Test your camera is connected with the "Test Camera Connection" button.
                                      If connected the text box below will fill with HTTP data from your camera.
                                      If not connected there will be no data.
                                      Save this HTTP data to file with the "Save Camera Data To File" button. This text file can be
                                      emailed to me at MSGEndoDoc@gmail.com so that I can improve the program.
     6.   App Transfer Images Page (Page 1)
                                 i)   Set the download directory ("Transfer Files to This Directory").  Camera images will end up here.
                                 ii)  Option 1: Press the grey triangle once to transfer images from camera to computer
                                      Option 2: Click the Repeat Timer checkbox and wait for the timer (e.g. 60s) to automate periodic image transfers.
     NOTE1:  Files downoaded will be remembered and not downloaded again on later transfers.
     NOTE2:  App Download History page (Page 2) lists all previously downloaded files.
             Deleted selected file records here will allow those images to be download again from the camera on later transfers.
     NOTE3:  The Download history is stored in the text file OlympusCameraDownloadRecord.txt.  Do not edit this file
     NOTE4:  The list of camera models with known connection URL are stroed in the ini file OlympusCameraModels.ini. Do not edit this file.'
     NOTE5:  Have added a filename prefix box in the GUI on Page 1 so downloaded image filenames will be prefixed by whatever you
             write in this box e.g. "Client John at Beach_300120_"   Note that you can not use char /,\,:,*,",<,>,| in filenames
     Enjoy

     Martin Gale (Copyright 2020)
     msgendodoc@gmail.com.au
     www.github.com/MSGENDO/OLYMPUSWIFI
     This program is open sourced and can be used for commercial and non commercial purposes (MIT licence) so long as
     full acknowledgement is made of the authors original contribution in any distribution of the derived work. The software is as is,
     and absolutely no warranty of suitability of purpose or efficacy is given, and the authors accept no liability whatsoever
     for its use, consequences or effects. If it is not suitable for your purpose then do not use this software.
     Otherwise, please make good use of it.

     See comments in the code for further explanations

  Enjoy

  Martin Gale
  msgendodoc@gmail.com

// TODO: There is still a very small memory leak somewhere of about $50k per access to the server - find this and fix it
// TODO: Work out how to automatically seek and connect to the WiFi SSID signal even though another wifi signal may previously be connected - on Win and Linux

}
  {$mode delphi}{$H+}
interface

uses
  Classes, SysUtils, ExtCtrls, Dialogs, fphttpclient, IniFiles
   {$IFDEF WINDOWS}
  ,win32proc   // Allows OSVersion to be defined for different Windows versions
   {$ENDIF}
  ;

Type   // An record for Olympus camera models held in a CSV database with fields:
       // Index, Camera Model Name, Camera Model Server Addr, Camera Model Root Dir DCIM.
 CameraVersion = record
   CID:         integer;
   CName:       String;
   CServerAddr: String;
   CRootDir:    String;
   CNotes:      String;
 end;

Type
 CameraVersions = array of CameraVersion;


Type
TImageFileInfo = record  // A single record of data for files or directories
  APath,
  AFileName,   // NB The Directory name is held in the AFilename field for FDirList
  AUnknown,
  AFileSize,
  ADate,
  ATime: String;
  ADownloaded: boolean;
end;

 TDCIMList  = array of TImageFileInfo; // An array of records for holding data about files or directories
 TDCIMLists = array of TDCIMList;      // An array of TDCIMList arrays for holding data about multiple dirctories of images
 ListTypes  = Set of (APath, AFileName, AUnknown, AFileSize, ADate, ATime, ADownloaded);  // Nominals for data types in TImageFileInfo

 { TTransferImages }  // depreciated as not using Threads as E-M10 MkIII can not accept multiple simultaneous downloads from more than one thread

//Type

 //TOnUpdateGUIEvent = procedure(PercentDone: integer) of Object;    // an event for the TThread to be assigned to a procedure in the main form of the aplication

 {NOTES
 I initally decided that using a TThread would speed up the image download from the camera and this worked for the OM-D E-M10 MkI but for the
 OM-D E-M10 MkIII there was a camera server error on starting a second or more threads while still downoading an earlier image. The MkIII camera server
 can only cope with one image download at a time. So unfortunately we can't use the threaded download now, and I wrote Function TOIShareReader.GetOneImage to do
 a non threaded download of each individual file, still allowing user intervention between files.  Presumably the SDCard directory and files downloads is so
 quick that the trheads overlapping are not a problem.
 }


{ TTransferImages = class(TThread) // The actual thread class for one event of accessing the Olympus camera server.  Using a TThread to free up the GUI
private
 FHTTPClient:       TfpHTTPClient;       // the http client component used to contact the server
 FHTTPRequest:      String;              // the string containing the request to the HTTP server
 FHTTPResponseSL:   TStringlist;         // the response in TStringList format
 FHTTPResponseMS:   TMemoryStream;       // the response in TMemoryStream format
 FResponseFilename: String;              // the path and filename for where to save the TStringlist or TMemoryStream response received from the HTTP server
 FErrorList:        TStringlist;         // holds a stringlist of any error messages encountered to be passed on to the user
 FOutputSort:      (oStrList, oMStream); // whether the thread asks for a TStringlist or a TMemoryStream from the server
public
 Constructor Create;
 Destructor  Destroy;  override;
 Function    GetHTTPResponseSL(AHTTPRequest: String; AResponseFilename: String): TStringlist;   // outputs a TStringlist from the server data
 Function    GetHTTPResponseMS(AHTTPRequest: String; AResponseFilename: String): TMemoryStream; // outputs a TMemoryStream from the server data
 procedure   Execute; override;                                                                 // Calls the seever
 end;

}
{ TOIShareReader }
Type
 TOIShareReader = class // The class which the uses the class TTransferImages classs to set up and receive data from the Olympus camera SD card server.

private
 FHTTPRecord:       TStringlist;    // Records the camera server HTTP output for analysis and testing
 FServerAddr:       string;         // The TfpHTTPClient URL to reach the camera server - typically for Olympus cameras 'http://oishare' with '/DCIM' added to access the image root directory
 FDCIMDir:          string;         // The SD card root directory for images - typically '/DCIM'
 FDirList:          TDCIMList;      // An array of folder information in the SD card root /DCIM directory
 FImageLists:       TDCIMLists;     // A set of arrays of image information, one array for one SD card directory
 FDownLoadDir:      string;         // Stores the destination directory for images on download
 FDownloadedList:   TStringList;    // A list of all the previous image downloads done - referenced so previous images are not downloaded again
 FLastDownloadTime: TDateTime;      // Time of last download
 FLastDownLoaded:   string;         // The path and filename for the last downloaded image
 FCurrentCamera:    integer;        // The currently selected camera
 FCameraModels:     CameraVersions; // An list of possible camera models;
 FIsConnected:      Boolean;
 FFilePrefix:       String;

 Procedure   Initialize;
 Procedure   CleanUp;
 Function    FindDownloadRecord(FindThis: String): integer;
 Function    GetOSVersion: String;
 //Function    GetDCIMResponseSL(AHTTPRequest: String; AResponseFilename: String): TStringlist;     // Returns a TStringlist   // depreciated
 //Function    GetDCIMResponseMS(AHTTPRequest: String; AResponseFilename: String): TMemoryStream;   // Returns a TMemoryStream // depreciated
 Function    GetHTTPResponseSL(AHTTPRequest: String;  AResponseFilename: String): TStringList;    // Retuns a TStringlist
 Function    GetHTTPResponseMS(AHTTPRequest: String; AResponseFilename: String): TMemoryStream;
 Function    GetDCIMList(AHTTPResponse: TStringList): TDCIMList;                                  // Generic function to turn the Javascript response into an array of file data
 Function    GetDCIMDirList(AServerURL: String): TDCIMList;                                       // Specific response to use GetDCIMDirList to retrieve SD card directory data
 Function    GetDCIMImageList(ADir: String): TDCIMList;                                           // Specific response to use GetDCIMDirList to retrieve SD card image file data

public

Const HelpText = 'HOW TO USE THIS PROGRAM' + #13 + #10 + // TODO: need different EOL for Linux/macOS
'  ' + #13 + #10 +
'  1.   Take some photos on your Olympus camera ' + #13 + #10 +
'  2.   Use the Olympus camera menu to select Connection to Smartphone.  This starts the camera WiFi server. ' + #13 + #10 +
'  3.   Connect your computer to this WiFi signal in the usual way for your operating system ' + #13 + #10 +
'  4.   Run this OlympusWIFI program ' + #13 + #10 +
'  5.   App Settings (Page 3): i)   Select your model of camera.  If your model is not there then use the Add button to add it. ' + #13 + #10 +
'                              ii)  Ensure the "Olympus Camera Server URL" is set correctly. ' + #13 + #10 +
'                                   This is the same URL address minus the "/DCIM" you can type into a web browser to access your camera. ' + #13 + #10 +
'                                   Change the server URL if needed ' + #13 + #10 +
'                                   e.g. Model E-M10 Mark I URL = "http://oishare", Model E-M10 Mark III URL = "http://192.168.0.10"  ' + #13 + #10 +
'                              iii) Ensure the "SDCard Root Directory" is set correctly. This is usually "/DCIM". Need initial forward slash. ' + #13 + #10 +
'                              iv)  Test your camera is connected with the "Test Camera Connection" button. ' + #13 + #10 +
'                                   If connected the text box below will fill with HTTP data from your camera.  ' + #13 + #10 +
'                                   If not connected there will be no data. ' + #13 + #10 +
'                                   Save this HTTP data to file with the "Save Camera Data To File" button. This text file can be ' + #13 + #10 +
'                                   emailed to me at MSGEndoDoc@gmail.com so that I can improve the program.   ' + #13 + #10 +
'  6.   App Transfer Images Page (Page 1)  ' + #13 + #10 +
'                              i)   Set the download directory ("Transfer Files to This Directory").  Camera images will end up here. ' + #13 + #10 +
'                              ii)  Option 1: Press the grey triangle once to transfer images from camera to computer ' + #13 + #10 +
'                                   Option 2: Click the Repeat Timer checkbox and wait for the timer (e.g. 60s) to automate periodic image transfers. ' + #13 + #10 +
'  NOTE1:  Files downoaded will be remembered and not downloaded again on later transfers. ' + #13 + #10 +
'  NOTE2:  App Download History page (Page 2) lists all previously downloaded files. ' + #13 + #10 +
'          Deleted selected file records here will allow those images to be download again from the camera on later transfers. ' + #13 + #10 +
'  NOTE3:  The Download history is stored in the text file OlympusCameraDownloadRecord.txt.  Do not edit this file ' + #13 + #10 +
'  NOTE4:  The list of camera models with known connection URL are stroed in the ini file OlympusCameraModels.ini. Do not edit this file.' + #13 + #10 +
'  NOTE5:  Have added a filename prefix box in the GUI on Page 1 so downloaded image filenames will be prefixed by whatever you ' + #13 + #10 +
'          write in this box e.g. "Client John at Beach_300120_"   Note that you can not use char /,\,:,*,",<,>,| in filenames ' + #13 + #10 +
'  ' + #13 + #10 +
'  Enjoy ' + #13 + #10 +
'  ' + #13 + #10 +
'  Martin Gale (Copyright 2020) ' + #13 + #10 +
'  msgendodoc@gmail.com.au ' + #13 + #10 +
'  www.github.com/MSGENDO/OLYMPUSWIFI  ' + #13 + #10 +
'  This program is open sourced and can be used for commercial and non commercial purposes (MIT licence) so long as ' + #13 + #10 +
'  full acknowledgement is made of the authors original contribution in any distribution of the derived work. The software is as is, ' + #13 + #10 +
'  and absolutely no warranty of suitability of purpose or efficacy is given, and the authors accept no liability whatsoever  ' + #13 + #10 +
'  for its use, consequences or effects. If it is not suitable for your purpose then do not use this software.   ' + #13 + #10 +
'  Otherwise, please make good use of it. ' + #13 + #10;

var
 ErrorList:  TStringList;   // Holds a listing of any errors encountered in the program.
 IsDownloading: boolean;    // Prevents further attepts at server contact when server already connected
 //TransferNow: TTransferImages;  // Depreciated

 Constructor Create;
 Destructor  Destroy; override;
 Procedure   RegisterAllSDCardFilesAsDownloaded;
 Function    RemoveEqualsSign(S: String): String;
 Function    RemoveIllegalFilenameChar(S: String): String;
 Procedure   RememberDownloadDir;
 //Procedure   RememberServerAddr;   // depreciated
 //Procedure   RememberSDRootDir;    // depreciated
 Function    CountFilesForDownload: integer;
 Function    DCIMListToStringList(ADCIMList: TDCIMList; AListTypes: ListTypes): TStringList;
 Procedure   GetSDCardData;
 Procedure   DownloadImages(SaveImageDir: String);
 Function    BeautifyDownloadList: TStringList;
 Function    CameraModelsToList: TStringList;
 Procedure   UpdateCameraSettingsFromModel(CameraID: integer);
 Procedure   SaveCameraSettingsToModel;
 Procedure   AddNewCameraModel(AName: String);
 Procedure   LoadCameraModelData;
 Procedure   SaveCameraModelData;

Published
 property ServerAddr:       string         read FServerAddr       write FServerAddr;        // typically for Olympus camera 'http://oishare'
 property DCIMDir:          string         read FDCIMDir          write FDCIMDir;           // typically '/DCIM'
 property DirList:          TDCIMList      read FDirList          write FDirList;           // As above in private section
 property ImageLists:       TDCIMLists     read FImageLists       write FImageLists;        //                   "
 property HTTPRecord:       TStringlist    read FHTTPRecord       write FHTTPRecord;        //                   "
 property DownloadDir:      String         read FDownloadDir      write FDownloadDir;       //                   "
 property DownloadList:     TStringList    read FDownloadedList   write FDownloadedList;    //                   "
 property LastDownLoadTime: TDateTime      read FLastDownLoadTime write FLastDownLoadTime;  //                   "
 property LastDownlowdedImage: String      read FLastDownloaded   write FLastDownloaded;    //                   ?
 property CurrentCamera:    integer        read FCurrentCamera    write FCurrentCamera;     // The currently selected camera
 property CameraModels:     CameraVersions read FCameraModels     write FCameraModels;      // The array of possible camer models
 property IsConnected: Boolean             read FIsConnected      write FIsConnected;       // Camera was successfully connected
 property FileNamePrefix: string           read FFilePrefix       write FFilePrefix;        // Image filename rename prefix (e.g. 'BeachPhotos_'
end;

implementation

 uses Olympus_ImageSave1;

{ TTransferImages } // TThread for the actual server communication so GUI is not locked and can be updated   // depreciated
{
constructor TTransferImages.Create;
begin
  inherited Create(false);   // false indicates the thread is not suspended, so it begins to run as soon as the constructor is finished
  FreeOnTerminate := false;  // Need to access info first, before free the TThread so dont free on terminate
  FHTTPClient     := TfpHTTPClient.create(nil);
  FHTTPResponseSL := TStringlist.create;
  FHTTPResponseMS := TMemoryStream.create;
  FErrorList      := TStringlist.create;
  FOutputSort     := oStrList;                // default is a stringlist
end;

destructor TTransferImages.Destroy;      // depreciated
begin
  //FHTTPClient.free;      // These objects should be freed before the TThread is freed but if do so then access violation so
  //FHTTPResponseSL.free;  // it seems that the TThread class destroy method frees them later anyway.
  //FHTTPResponseMS.free;
  //FErrorList.free;
  inherited destroy;
end;

function TTransferImages.GetHTTPResponseSL(AHTTPRequest: String; AResponseFilename: String): TStringlist;     // depreciated
begin   // Arranges to GET a TStringlist from the server, with the variable FOutputSort flagging the output is to be a stringlist
  FOutputSort       := oStrList;
  FHTTPRequest      := AHTTPRequest;
  FResponseFilename := AResponseFilename;
  Execute;
  Result            := FHTTPResponseSL;
end;

function TTransferImages.GetHTTPResponseMS(AHTTPRequest: String; AResponseFilename: String): TMemoryStream;   // depreciated
begin   // Arranges to GET a TMemoyStream from the server, with the variable FOutputSort flagging the output is to be a memorystream
  FOutputSort       := oMStream;
  FHTTPRequest      := AHTTPRequest;
  FResponseFilename := AResponseFilename;
  Execute;
  Result            := FHTTPResponseMS;
end;

procedure TTransferImages.Execute;   // depreciated
begin   // THis uses TfpHTTPClient to get from the server either a TStringlist of text or else a TMemorystream of data depending on the
        // FOuptutSource flag setting. If there is a valid directory defined by FResponseFilename, then the file either as text or data,
        // will be saved to this given directory

 If (FHTTPClient  <> nil)                      and
    (FHTTPRequest <> '')                       then
//    (FHTTPRequest.Contains('http://oishare')) then     // Usually 'http://oishare' for olympus cameras
                                                         // can't expect this as some cameras emit an IP address e.g. 192.168.1.10
 Try                                                                                          // For OM-D E-M10 MkI SimpleGet works both times. For OM-D E-M10 Mark III
   If FOutputSort = oStrList then FHTTPClient.SimpleGet(FHTTPRequest, FHTTPResponseSL) else   // SimpleGet works for SD card data retrieval not for file retrieval
   If FOutputSort = oMStream then FHTTPClient.Get(FHTTPRequest, FHTTPResponseMS);             // where Get works.   Why?

   // Save server response file to disk only if a filename with valid path has been given
   If   (FResponseFilename > '') and
        (DirectoryExists(ExtractFilePath(FResponseFilename))) then
     Try
       If FOutputSort = oStrList then FHTTPResponseSL.SaveToFile(FResponseFilename) else
       If FOutputSort = oMStream then FHTTPResponseMS.SaveToFile(FResponseFilename);
     except
       FErrorList.add('Sorry: Could not save file ' + FResponseFilename + ' [' + DateTimeToStr(Now,False) + ']');
     end;
 except;
   //beep;
   If FOutputSort = oStrList then FHTTPResponseSL.clear else
   If FOutputSort = oMStream then FHTTPResponseMS.clear;
   FErrorList.add('Sorry: The Olympus camera could not be reached at ' + FHTTPRequest + ' [' + DateTimeToStr(Now,False) + ']');
 end;
end;
}
{ TOIShareReader }

constructor TOIShareReader.Create;
begin
 Initialize;
end;

destructor TOIShareReader.Destroy;
begin
  CleanUp;
  inherited destroy;
end;

function TOIShareReader.GetOSVersion: String;  // Works out which operating system so can decide whether to use / or \ in paths
                                               // From https://forum.lazarus.freepascal.org/index.php?topic=15390.0   ( Thanks jwdietrich! )
begin
  {$IFDEF LCLcarbon}
  GetOSVersion := 'MacOS.';
  {$ELSE}
    {$IFDEF Linux}
    GetOSVersion := 'Linux';
    {$ELSE}
      {$IFDEF UNIX}
       Get OSVersion := 'Unix ';
      {$ELSE}
        {$IFDEF WINDOWS}
        // Need to have Win32Proc unit in the uses clause for this to work
        If WindowsVersion       = wv95         then GetOSVersion := 'Windows 95 '
         else if WindowsVersion = wvNT4        then GetOSVersion := 'Windows NT v.4 '
         else if WindowsVersion = wv98         then GetOSVersion := 'Windows 98 '
         else if WindowsVersion = wvMe         then GetOSVersion := 'Windows ME '
         else if WindowsVersion = wv2000       then GetOSVersion := 'Windows 2000 '
         else if WindowsVersion = wvXP         then GetOSVersion := 'Windows XP '
         else if WindowsVersion = wvServer2003 then GetOSVersion := 'Windows Server 2003 '
         else if WindowsVersion = wvVista      then GetOSVersion := 'Windows Vista '
         else if WindowsVersion = wv7          then GetOSVersion := 'Windows 7 '
         else if WindowsVersion = wv8          then GetOSVersion := 'Windows 8 '      // MG added to update the code
         else if WindowsVersion = wv8_1        then GetOSVersion := 'Windows 8.1 '    //          "
         else if WindowsVersion = wv10         then GetOSVersion := 'Windows 10 '     //          "
         else if WindowsVersion = wvLater      then GetOSVersion := 'Windows >10 '    //          "
         // what about windows 10?
         else                                       GetOSVersion := 'Windows ';
        {$ENDIF}
      {$ENDIF}
    {$ENDIF}
  {$ENDIF}
end;

procedure TOIShareReader.Initialize;     // Sets up the program initial default state
var
  a: integer;
begin
  FHTTPRecord       := TStringlist.create;
  FServerAddr       := 'http://oishare'; // 'http://oishare' typically for Olympus camera. 'http://oishare/DCIM' to access files (no need for /*.*)
  FDCIMDir          := '/DCIM';          // typically '/DCIM'
  SetLength(FDirList,0);
  SetLength(FImageLists,0);
  ErrorList         := TStringList.create;
  FDownLoadDir      := GetCurrentDir;
  FDownloadedList   := TStringList.create;
  FLastDownloadTime := Now;
  FLastDownloaded   := '';
  IsDownloading     := false;
  IsConnected       := false;
  FileNamePrefix    := '';
  Try
    {$IFDEF WINDOWS}
    FDownloadedList.LoadFromFile(GetCurrentDir + '\OlympusCameraDownloadRecord.txt');
    {$ELSE}
    FDownloadedList.LoadFromFile(GetCurrentDir + '/OlympusCameraDownloadRecord.txt');
    {$ENDIF}
  Except;
    FDownloadedList := TStringList.create;
  end;
    CurrentCamera := 0;  // default
    Setlength(FCameraModels,1);
    LoadCameraModelData;
    UpdateCameraSettingsFromModel(CurrentCamera);

  // Load the previous run's PC's download directory
    a := FindDownloadRecord('DownloadDir='); // if no string found then -1
    If (a > -1) and (length(FDownloadedList.strings[a]) > 12) then // i.e. 'DownloadDir='
    FDownLoadDir := Copy(FDownloadedList.strings[a],13,length(FDownloadedList.strings[a])-12) else
    FDownloadDir := GetCurrentDir;
    If not DirectoryExists(FDownLoadDir) then FDownloadDir := GetCurrentDir;

    // Load the previous run's camera's server address  // depreciated - now using OlympusCameraModels.ini
    //a := FindDownloadRecord('CameraURL='); // if no string found then -1
    //If (a > -1) and (length(FDownloadedList.strings[a]) > 10) then // i.e. 'CameraURL='
    //FServerAddr := Copy(FDownloadedList.strings[a],11,length(FDownloadedList.strings[a])-10) else
    //FServerAddr := 'http://oishare';

    // Load the previous run's camera's root dir        // depreciated - now using OlympusCameraModels.ini
    //a := FindDownloadRecord('CameraROOTDir='); // if no string found then -1
    //If (a > -1) and (length(FDownloadedList.strings[a]) > 14) then // i.e. 'CameraROOTDir='
    //FDCIMDir := Copy(FDownloadedList.strings[a],15,length(FDownloadedList.strings[a])-14) else
    //FDCIMDir := '/DCIM';
end;

procedure TOIShareReader.CleanUp;        // Organises the final program state
var
  a: integer;
begin
  FreeAndNil(FHTTPRecord);
  SetLength(FDirList,0);
  For a := 0 to length(FImageLists) -1 do
  SetLength(FImageLists[a],0);
  SetLength(FImageLists,0);
  RememberDownloadDir;
  //RememberServerAddr;  // depreciated - now using OlympusCameraModels.ini
  //RememberSDRootDir;   // depreciated - now using OlympusCameraModels.ini
  SaveCameraModelData;
  Setlength(FCameraModels,0);
  {$IFDEF WINDOWS}
  FDownloadedList.SaveToFile(GetCurrentDir + '\OlympusCameraDownloadRecord.txt');
  {$ELSE}
  FDownloadedList.SaveToFile(GetCurrentDir + '/OlympusCameraDownloadRecord.txt');
  {$IFEND}
  FreeAndNil(FDownloadedList);
  FreeAndNil(ErrorList);
end;

procedure TOIShareReader.LoadCameraModelData;  // Loads all the camera model details from an ini file
var
 a: integer;
 IFile: Tinifile;
begin
  Try
    //If Fileexists(GetCurrentDir + '/OlympusCameraModels.ini') then
    {$IFDEF WINDOWS}
    IFile := TInifile.create(GetCurrentDir + '\OlympusCameraModels.ini');
    {$ELSE}
    IFile := TInifile.create(GetCurrentDir + '/OlympusCameraModels.ini');
    {$ENDIF}
    a := IFile.ReadInteger('CAMERA_MODELS', 'NumModels', 1); // i.e.  if none yet, set up one default camera model
    FCurrentCamera := IFile.ReadInteger('CAMERA_models', 'CurrentModel',1);
    If FCurrentCamera > a -1 then FCurrentCamera := a -1;
    SetLength(FCameraModels,a);
    For a := 0 to length(FCameraModels) -1 do
    begin;                                                                       // Sets these default values if no info in IniFile yet
      FCameraModels[a].CID         := IFile.ReadInteger('CAMERA_' + InttoStr(a), 'C_Index',       0);
      FCameraModels[a].CName       := IFile.ReadString ('CAMERA_' + InttoStr(a), 'C_Name',       'OM-D E-M10 (Mark I)');
      FCameraModels[a].CServerAddr := IFile.ReadString ('CAMERA_' + InttoStr(a), 'C_ServerAddr', 'http://oishare');
      FCameraModels[a].CRootDir    := IFile.ReadString ('CAMERA_' + InttoStr(a), 'C_ROOTDIR',    '/DCIM');
      FCameraModels[a].CNotes      := IFile.ReadString ('CAMERA_' + InttoStr(a), 'C_NOTES',       'No Notes');
    end;
  Finally
    FreeAndNil(IFile);
  end;
end;

procedure TOIShareReader.SaveCameraModelData;  // Saves all the camera model details to an ini file
var
 a: integer;
 IFile: Tinifile;
begin
  Try
    {$IFDEF WINDOWS}
    IFile := TInifile.create(GetCurrentDir + '\OlympusCameraModels.ini');
    {$ELSE}
    IFile := TInifile.create(GetCurrentDir + '/OlympusCameraModels.ini');
    {$ENDIF}
    IFile.WriteInteger('CAMERA_MODELS', 'NumModels', length(FCameraModels));
    IFile.WriteInteger('CAMERA_models', 'CurrentModel', FCurrentCamera);
    For a := 0 to length(FCameraModels) -1 do
    begin;
      IFile.WriteInteger('CAMERA_' + InttoStr(a), 'C_Index',      FCameraModels[a].CID);         //,'0'
      IFile.WriteString ('CAMERA_' + InttoStr(a), 'C_Name',       FCameraModels[a].CName);       //,'OM-D E-M10 Mark I');
      IFile.WriteString ('CAMERA_' + InttoStr(a), 'C_ServerAddr', FCameraModels[a].CServerAddr); //,'http://oishare');
      IFile.WriteString ('CAMERA_' + InttoStr(a), 'C_ROOTDIR',    FCameraModels[a].CRootDir);    //,'/DCIM');
      IFile.WriteString ('CAMERA_' + InttoStr(a), 'C_NOTES',      FCameraModels[a].CNotes);      //,'');
    end;
  Finally
    FreeAndNil(IFile);
  end;
end;

procedure TOIShareReader.RegisterAllSDCardFilesAsDownloaded;
var            // Checks the SD card for files and marks them all as previously downloaded
 a,b: integer; // This is useful if you start using an SD card from another camera which has many previous images on it
begin;         // which have not been downloaded by this program, and you do not wish to download these historical images now
  GetSDCardData;
  If length(FImageLists) > 0 then
  For a := 0 to length(FImageLists) -1 do
  begin;
    If (length(FImageLists[a]) > 0) then
    For b := 0 to length(FImageLists[a]) -1 do
    begin
      FImageLists[a].[b].ADownloaded := true;
      If not FDownloadedList.Text.Contains(
             FImageLists[a].[b].APath + '$!?' + FImageLists[a].[b].AFileName + '$!?' +
             FImageLists[a].[b].ADate + '$!?' + FImageLists[a].[b].ATime) then
      FDownloadedList.add(
             FImageLists[a].[b].APath + '$!?' + FImageLists[a].[b].AFileName + '$!?' +
             FImageLists[a].[b].ADate + '$!?' + FImageLists[a].[b].ATime     + '$!?' + BoolToStr(FImageLists[a].[b].ADownloaded));
    end;
  end;
  RememberDownloadDir;
  //RememberServerAddr;   // Depreciated as now using OlympusCameraModels.ini  // depreciated - now using OlympusCameraModels.ini
  //RememberSDRootDir;    // Depreciated as now using OlympusCameraModels.ini  // depreciated - now using OlympusCameraModels.ini
  {$IFDEF WINDOWS}
  Try FDownloadedList.SaveToFile(GetCurrentDir + '\OlympusCameraDownloadRecord.txt');
  except
    beep;
    ErrorList.add('Sorry: Could not save the list of downloaded files at: ' + GetCurrentDir + '\OlympusCameraDownloadRecord.txt' + ' [' + DateTimeToStr(Now,False) + ']');
  end;
  {$ELSE}
  FDownloadedList.SaveToFile(GetCurrentDir + '/OlympusCameraDownloadRecord.txt');
  {$ENDIF}
end;

Function TOIShareReader.RemoveEqualsSign(S: String): String;
var
 a: integer;
begin;
  If S > '' then
  Repeat
    a := Pos('=', S);               // Will be used in an ini file later so can ot have = sign
    If a > 0 then
    delete(S, a, 1);
  until Pos('=', S) = 0;
  Result := S;
end;

Function TOIShareReader.RemoveIllegalFilenameChar(S:String): String;  // Remove illegal file name characters
var
 a: integer;
 ts1: String;
begin;
 ts1 := S;
 a := 1;
 If length(ts1) > 0 then
 Repeat
  If (length(ts1) > 0) and
     (ts1[a] in ['/','\',':','*','"','<','>','|']) then  // these char for Windows  - what about Linux, Mac?
  begin;
    delete(ts1,a,1);
    If a > 1 then dec(a);
  end;
  Inc(a);
 until a > length(ts1);
 Result := ts1;
end;

function TOIShareReader.CountFilesForDownload: integer; // Counts how many images need downloading
var             // Updates and tallies the number of image files on the SD card due for downoad
 a, b: integer; // Make sure you run GetSDCardData first to have a fresh file listing
begin;
  Result := 0;
  For a := 0 to length(FImageLists) -1 do
  begin;
    For b := 0 to length(FImageLists[a]) -1 do
    begin;
      If FDownloadedList.Text.Contains(  // checks the download records again to be sure, and updates ADownloaded field
         FImageLists[a].[b].APath + '$!?' + FImageLists[a].[b].AFileName + '$!?' +
         FImageLists[a].[b].ADate + '$!?' + FImageLists[a].[b].ATime) then
         FImageLists[a].[b].ADownloaded := true else
         FImageLists[a].[b].ADownloaded := false;
      If FImageLists[a].[b].ADownloaded = false then
      Inc(Result);
    end;
  end;
end;

function TOIShareReader.FindDownloadRecord(FindThis: String): integer;
var                  // Identifies where the download directory record is in the OlympusCameraDownloadRecord.txt file
  a, Found: integer; // All this so I dont use TIniFile which is not available on Linux, Mac!
begin
  Result := -1;
  Found  := -1;
  If (FDownloadedList <> nil)    and
     (FDownloadedList.count > 0) then
  begin;
    a     := 0;
    Found := -1;
    Repeat
      If FDownloadedList[a].contains(FindThis) then
      Found := a;
      inc(a);
    until (Found > -1)                or
          (a > FDownloadedList.Count -1);
  end;
  Result := Found;
end;
{
function TOIShareReader.GetDCIMResponseSL(AHTTPRequest: String; AResponseFilename: String): TStringlist;// Queries the Olympus camera http server for a response
var                                          // depreciated - now using OlympusCameraModels.ini
  AHTTPThread: TTransferImages;
begin;
  AHTTPThread := TTransferImages.create;
  Result      := AHTTPThread.GetHTTPResponseSL(AHTTPRequest,AResponseFilename);
  FHTTPRecord.AddStrings(Result);
  ErrorList.AddStrings(AHTTPThread.FErrorList);
  AHTTPThread.Free;
end;

function TOIShareReader.GetDCIMResponseMS(AHTTPRequest: String;  AResponseFilename: String): TMemoryStream; // Queries the Olympus camera http server for a response
var                                         // depreciated - now using OlympusCameraModels.ini
  AHTTPThread: TTransferImages;
begin;
  AHTTPThread := TTransferImages.create;
  Result      := AHTTPThread.GetHTTPResponseMS(AHTTPRequest,AResponseFilename);
  ErrorList.AddStrings(AHTTPThread.FErrorList);
  AHTTPThread.Free;
end;
}
Function TOiShareReader.GetHTTPResponseSL(AHTTPRequest: String;  AResponseFilename: String): TStringList;
var
  AHTTPClient: TfpHTTPClient;
  AHTTPResponseSL: TStringList;
begin;
  Result := nil;
  AHTTPClient := TfpHTTPClient.create(nil);
  AHTTPResponseSL := TStringList.create;
  If (AHTTPRequest <> '') then
  Try
    AHTTPClient.SimpleGet(AHTTPRequest, AHTTPResponseSL);
    FHTTPRecord.AddStrings(AHTTPResponseSL);
    // Save server response file to disk only if a filename with valid path has been given
    If   (AResponseFilename > '') and
         (DirectoryExists(ExtractFilePath(AResponseFilename))) then
      Try
        AHTTPResponseSL.SaveToFile(AResponseFilename);
      except
        ErrorList.add('Sorry: Could not save file ' + AResponseFilename + ' [' + DateTimeToStr(Now,False) + ']');
      end;
  except;
    ErrorList.add('Sorry: The Olympus camera could not be reached at ' + AHTTPRequest + ' [' + DateTimeToStr(Now,False) + ']');
  end;
  Result := AHTTPResponseSL;
  FreeAndNil(AHTTPClient);
  //FreeAndNil(AHTTPResponseMS);  // dont free otherwise result is nil but remember to free it externally

end;

Function TOIShareReader.GetHTTPResponseMS(AHTTPRequest: String; AResponseFilename: String): TMemoryStream;  // Non threaded - to test if multiple threads a problem for camera server
var
  AHTTPClient: TfpHTTPClient;
  AHTTPResponseMS: TMemoryStream;
begin;
  Result := nil;
  AHTTPClient := TfpHTTPClient.create(nil);
  AHTTPResponseMS := TMemoryStream.create;
  If (AHTTPRequest <> '') then
  Try
    AHTTPClient.SimpleGet(AHTTPRequest, AHTTPResponseMS);
    // Save server response file to disk only if a filename with valid path has been given
    If   (AResponseFilename > '') and
         (DirectoryExists(ExtractFilePath(AResponseFilename))) then
      Try
        AHTTPResponseMS.SaveToFile(AResponseFilename);
      except
        ErrorList.add('Sorry: Could not save file ' + AResponseFilename + ' [' + DateTimeToStr(Now,False) + ']');
      end;
  except;
    ErrorList.add('Sorry: The Olympus camera could not be reached at ' + AHTTPRequest + ' [' + DateTimeToStr(Now,False) + ']');
  end;
  Result := AHTTPResponseMS;
  FreeAndNil(AHTTPClient);
  //FreeAndNil(AHTTPResponseMS);  // dont free otherwise result is nil but remember to free it externally
end;

function TOIShareReader.GetDCIMList(AHTTPResponse: TStringList): TDCIMList;  // Parses the wireless Olympus camera http server http response for directory or file info in included Javascript object
var                                                                          // NB: Need to specify System.delete for text deletions otherwaise calls TFPHTTPClient.delete instead
 ts1: string;
 a, b, S1, S2: integer;
 {THE FORMAT FOR THE CAMERA SERVER RESPONSE JAVASCRIPT ARRAY IS

 <script type="text/javascript">
 wlansd = new Array();
 wlansd[0]="/DCIM/101OLYMP/*.*,ZC080001.JPG,1072607,0,20360,31741";
 wlansd[1]="/DCIM/101OLYMP/*.*,ZC080002.JPG,1079420,0,20360,31752";
 ...


 WHERE THE CSV ELEMENTES DENOTE: PATH, FILENAME, FILESIZE, UNKNOWN, DATE, TIME
 Stil have yet to figure out what units the date and time are in
 }

begin
  Setlength(Result,0);
  If (AHTTPResponse <> nil)    and
     (AHTTPResponse.Count > 0) and
     (AHTTPResponse.Text.Contains('wlansd = new Array();')) then  // ie. The HTTPresponse contains a javascript array object called wlansd
  For a := 0 to AHTTPResponse.count -1 do
  begin;
    If (copy(AHTTPResponse[a],1,7) = 'wlansd[') and
       (AHTTPResponse[a].Contains('=')) then       // The Javascript wlansd object elements lines each begins with 'wlansd[' and has an '=' in it
    begin;                                         // i.e. this line is a Javascript wlansd object array element representing one image file
      Setlength(Result, length(Result) +1);
      b   := length(Result) -1;
      ts1 := AHTTPResponse[a];
      S1  := pos('=', ts1) + 2;                    // locates the second character after the '=' sign in each wlansd object array line
      If (S1 > 0)            and
         (S1 <= length(ts1)) then
      begin;
        ts1 := copy(ts1, S1, length(ts1) - S1 -1); // grabs the quoted string including six comma separated data values, also not including the trailing ;
        // remove the two " quotation characters
        If pos('"', ts1) > 0 then System.delete(ts1, pos('"', ts1), 1);
        If pos('"', ts1) > 0 then System.delete(ts1, pos('"', ts1), 1);

        // Now parse the javascript in the server response for the six comma separated data for each image file in this array

        // APath
        S2 := Pos(',',ts1) ;
        If S2 > 0 then
        begin;
          Result[b].APath := copy(ts1, 1, S2 -1); // -1 so removes the , at the end of the http get path call
          System.Delete(ts1,1,S2);                // deletes commma    // NB: The path name does not include the server name 'http://oishare',
                                                  // and uses unix '/' path delimiters.  The path sometimes includes an initial and trailing '/'
          If pos('/*.*', Result[b].APath) > 0 then
          System.delete(Result[b].APath, pos('/*.*', Result[b].APath), 4) else // Gets rid of all of /*.* if present on the path string
          If Result[b].APath[length(Result[b].APath)] = '/' then
          System.delete(Result[b].APath, length(Result[b].APath), 1)   ;       // or gets rid of just / if present on path string
          // i.e the path has no trailing forward slash or *.* any more. But actually this works on requesting the file list from the server. Dont need /*.*
        end;

        //AFilename
        S2 := Pos(',',ts1);
        If S2 > 0 then
        begin;
          Result[b].AFileName := copy(ts1, 1, S2-1);
          System.Delete(ts1,1,S2);
        end;

        //AFileSize
        S2 := Pos(',',ts1);
        If S2 > 0 then
        begin;
          Result[b].AFileSize := copy(ts1, 1, S2-1);
          System.Delete(ts1,1,S2);
        end;

        //AUnknown - not sure what this represents but it seems to be always 0
        S2 := Pos(',',ts1);
        If S2 > 0 then
        begin;
          Result[b].AUnknown := copy(ts1, 1, S2-1);
          System.Delete(ts1,1,S2);
        end;

        //ADate      // Have assumed this integer value is the date - not sure of the format yet
        S2 := Pos(',',ts1);
        If S2 > 0 then
        begin;
          Result[b].ADate := copy(ts1, 1, S2-1);
          System.Delete(ts1,1,S2);
        end;

        //ATime     // Have assumed this integer value is the timestamp - not sure of the format yet
        S2 := Pos(',',ts1);
        If (S2 = 0) and (length(ts1) > 0) then    // ie no commas left
        begin;
          Result[b].ATime := copy(ts1, 1, length(ts1));
          //System.Delete(ts1,1,S2);  // No terminal comma to delete here
        end;
        // Have used the field delimiter '$!?' as this is unlikely to be in any directory or filename
        // Downloaded already?           // format    /DCIM/101OLYMP$!?ZC110024.JPG$!?20363$!?32035$!?-1
        If FDownloadedList.Text.Contains
        (Result[b].APath + '$!?' + Result[b].AFileName + '$!?' + Result[b].ADate + '$!?' + Result[b].ATime) then
           Result[b].ADownloaded := true else
           Result[b].ADownloaded := false;
      end;
    end;
  end;
end;

procedure TOIShareReader.RememberDownloadDir;    // Update the saved download directory to file too
var
  a: integer;
begin
  a := FindDownloadRecord('DownloadDir=');
  If a > -1 then
  FDownloadedList[a] :=    'DownloadDir=' + FDownloadDir  else
  FDownloadedList.Insert(0,'DownloadDir=' + FDownloadDir);
end;

{procedure TOIShareReader.RememberServerAddr;    // Update the saved download directory to file too
var                                              // Depreciated - now using the OlympusCameraModels.ini file
  a: integer;
begin
  a := FindDownloadRecord('CameraROOTDir=');
  If a > -1 then
  FDownloadedList[a] :=    'CameraROOTDir=' + FDCIMDir  else
  If FDownloadedList.count > 1 then
  FDownloadedList.Insert(1,'CameraROOTDir=' + FDCIMDir) else
  FDownloadedList.add('CameraROOTDir=' + FDCIMDir);
end;

procedure TOIShareReader.RememberSDRootDir;     // Update the saved download directory to file too
var                                             // Depreciated - now using the OlympusCameraModels.ini file
  a: integer;
begin
  a := FindDownloadRecord('CameraURL=');
  If a > -1 then
  FDownloadedList[a] :=   'CameraURL=' + FServerAddr  else
  If FDownloadedList.count > 1 then
  FDownloadedList.Insert(1,'CameraURL=' + FServerAddr) else
  FDownloadedList.add('CameraURL=' + FServerAddr);
end;
}
function TOIShareReader.GetDCIMDirList(AServerURL: String): TDCIMList; // Queries the server for a list of directories on the SD card
var
 AHTTPResponse: TStringList;
Begin;
  Setlength(Result,0);
  FServerAddr := AServerURL;
  If (length(FServerAddr) > 0) and
     (length(FDCIMDir)    > 0) then
  begin;
    If not (FDCIMDir[1] ='/') then
    insert('/',FDCIMDir,1); // Adds a prefix '/' if not present already in ADir FServerAddr + FDCIMDir
    AHTTPResponse := GetHTTPResponseSL(FServerAddr + FDCIMDir,'');   //'http://oishare/DCIM','');
    Result        := GetDCIMList(AHTTPResponse);                     // NB This TDCIMList needs to be freed externally - don't forget
    FreeAndNil(AHTTPResponse);
  end else
  ErrorList.add('Sorry: No Server address or SD card root directory were given to read' + ' [' + DateTimeToStr(Now,False) + ']'); ;;
end;

function TOIShareReader.GetDCIMImageList(ADir: String): TDCIMList; // Queries the server for a list of directories on the SD card
var
  AHTTPResponse: TStringList;
begin
  Setlength(Result,0);
  If (length(FDCIMDir) > 0) and
     (length(ADir)     > 0) then
  begin;
    If not (FDCIMDir[1] ='/') then
    insert('/',FDCIMDir,1); // Adds a prefix '/' if not present already in ADir FServerAddr + FDCIMDir
    If not (ADir[1] ='/') then
    insert('/',ADir,1); // Adds a prefix '/' if not present already in ADir FServerAddr + FDCIMDir
    AHTTPResponse := GetHTTPResponseSL(FServerAddr + FDCIMDir + ADir,'');  //'http://oishare/DCIM' + /directory
    Result        := GetDCIMList(AHTTPResponse);
    //FImageList    := GetDCIMList(AHTTPResponse);  // Do we want/need this to happen
    FreeAndNil(AHTTPResponse);
  end else
  ErrorList.add('Sorry: No SD card root directory or image directory name were given to read' + ' [' + DateTimeToStr(Now,False) + ']'); ;
end;

function TOIShareReader.DCIMListToStringList(ADCIMList: TDCIMList; AListTypes: ListTypes): TStringList;
         // Converts a DCIMList to a stringlist for use in GUI or for saving to file
var      // Listtypes allows you to specify which data fields to include in the stringlist output
  a: integer;
  ts1: string;
begin
  Result := TStringList.create;  // NB: Remember to free this externally - don't forget
  If (length(ADCIMList) > 0) and
     (AListTypes <> [])      then
  For a := 0 to length(ADCIMList) -1 do
  begin;
    ts1 := '';
    If APath       in AListTypes then ts1 := ts1 + ', ' + ADCIMList[a].APath;
    If AFileName   in AListTypes then ts1 := ts1 + ', ' + ADCIMList[a].AFileName;
    If AFileSize   in AListTypes then ts1 := ts1 + ', ' + ADCIMList[a].AFileSize;
    If AUnknown    in AListTypes then ts1 := ts1 + ', ' + ADCIMList[a].AUnknown;
    If ADate       in AListTypes then ts1 := ts1 + ', ' + ADCIMList[a].ADate;
    If ATime       in AListTypes then ts1 := ts1 + ', ' + ADCIMList[a].ATime;
    If ADownloaded in AListTypes then ts1 := ts1 + ', ' + BoolToStr(ADCIMList[a].ADownloaded,'Downloaded', 'Not Downloaded');
    If ts1 <> '' then System.delete(ts1,1,2);  // Remove unnecessary leading ', '
    Result.add(ts1);
  end else
  Result.text := 'No Data';
end;

procedure TOIShareReader.GetSDCardData; // Queries the SD card for a list of directories or data
var
  a: integer;
begin;
  //clear all previous lists to avoid memory leaks
  IsDownloading := true;
  FHTTPRecord.clear;
  SetLength(FDirList,0);
  For a := 0 to length(FImageLists) -1 do
  SetLength(FImageLists[a],0);
  SetLength(FImageLists,0);
  // Then read new SD card directory list FServerAddr  + FDCIMDir
  FDirList := GetDCIMDirList(FServerAddr); // NB: the '/DCIM' is added later not here
  // Then read each directory's image list
  If length(FDirList) > 0 then
  begin;
    Self.IsConnected := true;
    Setlength(FImageLists,length(FDirList));  // Make one image list for each directory
    For a := 0 to length(FImageLists) -1 do
    begin;
      FImageLists[a] := GetDCIMImageList(FDirList[a].AFileName); // Gets each image directory's file list for display
    end
  end else
  IsConnected := false;
 IsDownloading := false;
end;

procedure TOIShareReader.DownloadImages(SaveImageDir: String);
                        // Downloads any images found on the SD card which have not yet been downloaded
var                     // a is a directory iterator, b is an image interator
  a, b, c, d: integer;  // c is a counter of how many files downloaded at any point in time. d is the total number of files to be downloaded
  AHTTPRequest: string;
  FStream: TMemoryStream;
begin
  IsDownloading := true;
  If not DirectoryExists(SaveImageDir) then Try MkDir(SaveImageDir); Except; end;   // Tries to mke the receiving download dir if not already present
  If DirectoryExists(SaveImageDir) then
  begin;
    d := CountFilesForDownload;  // Also updates SDCard list of directories and files
    c := 0;
    FileNamePrefix := RemoveIllegalFilenameChar(FileNamePrefix);
    If (length(FImageLists) > 0) and (d > 0) then
    For a := 0 to length(FImageLists) -1 do
    begin;
    If IsDownloading = false then break;       // allows download escape from For loop if user wishes
      If length(FImagelists[a]) > 0 then
      begin;
        For b := 0 to length(FImagelists[a]) -1 do
        begin;
          If IsDownloading = false then break; // allows download escape from For loop if user wishes
          If not FImageLists[a].[b].ADownloaded then
          begin;
            AHTTPRequest :=  FServerAddr + FImageLists[a].[b].APath + '/' + FImageLists[a].[b].AFileName;
            {$IFDEF WINDOWS}
            //FStream := GetDCIMResponseMS(AHTTPRequest, SaveImageDir + '\' + FImageLists[a].[b].AFileName); // Queries the Olympus camera http server for a response, saves result to file
            // Testing without threads
            FStream := GetHTTPResponseMS(AHTTPRequest, SaveImageDir + '\' + FileNamePrefix + FImageLists[a].[b].AFileName);  // Non threaded - to test if multiple threads a problem for camera server

            {$ELSE}
//           FStream := GetDCIMResponseMS(AHTTPRequest, SaveImageDir + '/' + FImageLists[a].[b].AFileName); // Queries the Olympus camera http server for a response, saves result to file
             FStream := GetHTTPResponseMS(AHTTPRequest, SaveImageDir + '/' + FileNamePrefix + FImageLists[a].[b].AFileName);  // Non threaded - to test if multiple threads a problem for camera server
            // If Linux or Mac need a / not a \ in the path.
            {$ENDIF}
            FreeAndNil(FStream);
            FImageLists[a].[b].ADownloaded := true;
            //This records with a delimited string whether a file has been donwloaded before or not.
            // The string '$!?' is the delimiter - unikely this will be naturally in a file name

            FDownloadedList.add(FImageLists[a].[b].APath + '$!?' + FImageLists[a].[b].AFileName + '$!?' +
                                FImageLists[a].[b].ADate + '$!?' + FImageLists[a].[b].ATime     + '$!?' + BoolToStr(FImageLists[a].[b].ADownloaded));

            {$IFDEF WINDOWS}   // Cross platform hassle fixed
            FLastDownloaded := FDownloadDir + '\' + FileNamePrefix + FImageLists[a].[b].AFileName;   // records the path and filename of the last downloaded image for display
            {$ELSE}
            FLastDownloaded := Self.DownloadDir + '/' + FileNamePrefix + FImageLists[a].[b].AFileName;
            // If Linux or Mac need a / not a \ in the path.
            {$ENDIF}

            inc(c); // counts how many downloads already done so far, for updating the GUI Progressbar
            If (FileExists(FLastDownloaded)) and (not (Uppercase(ExtractFileExt(FLastDownloaded)) = '.ORF')) then
            Try
              If Uppercase(ExtractFileExt(FLastDownloaded)) = '.JPG' then
              Form_Main.ImageView.Picture.Jpeg.LoadFromFile(FLastDownloaded) else
              If Uppercase(ExtractFileExt(FLastDownloaded)) = '.BMP' then
              Form_Main.ImageView.Picture.Bitmap.LoadFromFile(FLastDownloaded);
            Except
              ErrorList.add('Sorry:  Could not dislay the last image downloaded (' + FLastDownloaded + ')');
              Form_Main.ImageView.Picture.Clear;
            end;
          end;  // Updates the GUI
          If c > 0 then Form_Main.OnUpdateGUI(round((c/d)*100)) else
                        Form_Main.ProgressBar1.Position := 0;
        end;
      end;

    end;
   end else
  ErrorList.add('Sorry: Could not find or create the download directory: ' + SaveImageDir + ' [' + DateTimeToStr(Now,False) + ']');
  RememberDownloadDir;
  SaveCameraModelData;
  //RememberServerAddr;   // depreciated - using OlymousCameraModels.ini now
  //RememberSDRootDir;    // depreciated - using OlymousCameraModels.ini now

  {$IFDEF WINDOWS}
  Try FDownloadedList.SaveToFile(GetCurrentDir + '\OlympusCameraDownloadRecord.txt');
  except
    //beep;
    ErrorList.add('Sorry: Could not save the list of downloaded files at: ' + GetCurrentDir + '\OlympusCameraDownloadRecord.txt' + ' [' + DateTimeToStr(Now,False) + ']');
  end;
  {$ELSE}
  FDownloadedList.SaveToFile(GetCurrentDir + '/OlympusCameraDownloadRecord.txt');
  {$ENDIF}
  FLastDownloadTime := Now;
  IsDownloading := false;
end;

function TOIShareReader.BeautifyDownloadList: TStringList;   // Removes the delimiters $!? for data display
var
  a: integer;
  ts1: string;
begin;
  If FDownloadedList <> nil then
  begin;
    ts1 := FDownloadedList.text;
    ts1 := ts1.Replace('$!?','    ',[rfReplaceAll]);        // NB need to free this TStringlist externally - don't forget
    Result := TStringlist.create;
    Result.text := ts1;

    a := FindDownloadRecord('DownloadDir=');
    If a > -1 then
    Result[a] := 'RECORD OF DOWNLOADED FILES';             // Removes the DownloadDir string in the TStringlist from user view
                                                           // but maintains that string in the TStringlist so count on delete lines is OK
    a := FindDownloadRecord('CameraROOTDir=');
    If a > -1 then
    Result[a] := '----';                                   // Removes the CameraROOTDir= string in the TStringlist from user view
                                                           // but maintains that string in the TStringlist so count on delete lines is OK
    a := FindDownloadRecord('CameraURL=');
    If a > -1 then
    Result[a] := '----';                                   // Removes the CameraROOTDir= string in the TStringlist from user view
                                                           // but maintains that string in the TStringlist so count on delete lines is OK
    end;
  end;

function TOIShareReader.CameraModelsToList: TStringList;
var
  a: integer;
begin;
  Result := TStringlist.create;        // remember to free this TStringlist externally
  If length(FCameraModels) > 0 then
  begin;
    For a := 0 to length(FCameraModels) -1 do
      Result.add(FCameraModels[a].CName);
  end;
end;

procedure TOIShareReader.UpdateCameraSettingsFromModel(CameraID: integer); // Sets the new camera model settings
begin
  If (CameraID > -1) and
     (CameraID < length(CameraModels)) then
  begin;
    FCurrentCamera := CameraID;
    FServerAddr    := CameraModels[CurrentCamera].CServerAddr;
    FDCIMDir       := CameraModels[CurrentCamera].CRootDir;
  end else
  begin;   // default if no current camera
    FCurrentCamera := 0;
    FServerAddr    := 'http://oishare';
    FDCIMDir       := '/DCIM';
  end;
end;

Procedure TOIShareReader.SaveCameraSettingsToModel;  // Updates or adds camera model details to the CameraModels array
begin;
 If (FCurrentCamera > -1)                    and
    (FCurrentCamera < length(FCameraModels)) then
 begin;
   FCameraModels[FCurrentCamera].CRootDir    := FDCIMDir;
   FCameraModels[FCurrentCamera].CServerAddr := FServerAddr;
 end; // else
// AddNewCameraModel('New Model_' + InttoStr(length(FCameraModels) - 1)); // Not sure we want to do this as name inappropriate?
end;

Procedure TOiShareReader.AddNewCameraModel(AName: String);
begin;   // Adds a new model if none present
  If AName <> '' then
  begin;
    AName := RemoveEqualsSign(AName);  // to be used in ini file so = signs not allowed
    Setlength(FCameraModels,length(FCameraModels) + 1);
    FCurrentCamera := length(FCameraModels) - 1;
    FCameraModels[FCurrentCamera].CID         := length(FCameraModels) - 1;
    FCameraModels[FCurrentCamera].CName       := AName;
    FCameraModels[FCurrentCamera].CRootDir    := FDCIMDir;
    FCameraModels[FCurrentCamera].CServerAddr := FServerAddr;
    FCameraModels[FCurrentCamera].CNotes      := 'No Notes';
  end;
end;

end.

